// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get meeting summaries
	// (GET /api/meetings/summary)
	GetMeetingSummaries(w http.ResponseWriter, r *http.Request)
	// Generate meeting summary
	// (POST /api/meetings/summary)
	GenerateMeetingSummary(w http.ResponseWriter, r *http.Request)
	// Get meeting summary by ID
	// (GET /api/meetings/summary/{MeetingID})
	GetMeetingSummaryById(w http.ResponseWriter, r *http.Request, meetingID string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetMeetingSummaries operation middleware
func (siw *ServerInterfaceWrapper) GetMeetingSummaries(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMeetingSummaries(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateMeetingSummary operation middleware
func (siw *ServerInterfaceWrapper) GenerateMeetingSummary(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateMeetingSummary(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMeetingSummaryById operation middleware
func (siw *ServerInterfaceWrapper) GetMeetingSummaryById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "MeetingID" -------------
	var meetingID string

	err = runtime.BindStyledParameterWithOptions("simple", "MeetingID", mux.Vars(r)["MeetingID"], &meetingID, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "MeetingID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMeetingSummaryById(w, r, meetingID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/api/meetings/summary", wrapper.GetMeetingSummaries).Methods("GET")

	r.HandleFunc(options.BaseURL+"/api/meetings/summary", wrapper.GenerateMeetingSummary).Methods("POST")

	r.HandleFunc(options.BaseURL+"/api/meetings/summary/{MeetingID}", wrapper.GetMeetingSummaryById).Methods("GET")

	return r
}

type GetMeetingSummariesRequestObject struct {
}

type GetMeetingSummariesResponseObject interface {
	VisitGetMeetingSummariesResponse(w http.ResponseWriter) error
}

type GetMeetingSummaries200JSONResponse map[string]interface{}

func (response GetMeetingSummaries200JSONResponse) VisitGetMeetingSummariesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetMeetingSummaries404JSONResponse ErrorResponse

func (response GetMeetingSummaries404JSONResponse) VisitGetMeetingSummariesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetMeetingSummaries500JSONResponse ErrorResponse

func (response GetMeetingSummaries500JSONResponse) VisitGetMeetingSummariesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GenerateMeetingSummaryRequestObject struct {
	Body *GenerateMeetingSummaryJSONRequestBody
}

type GenerateMeetingSummaryResponseObject interface {
	VisitGenerateMeetingSummaryResponse(w http.ResponseWriter) error
}

type GenerateMeetingSummary202JSONResponse GenerateMeetingSummaryResponse

func (response GenerateMeetingSummary202JSONResponse) VisitGenerateMeetingSummaryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type GenerateMeetingSummary404JSONResponse ErrorResponse

func (response GenerateMeetingSummary404JSONResponse) VisitGenerateMeetingSummaryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GenerateMeetingSummary409JSONResponse ErrorResponse

func (response GenerateMeetingSummary409JSONResponse) VisitGenerateMeetingSummaryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type GenerateMeetingSummary500JSONResponse ErrorResponse

func (response GenerateMeetingSummary500JSONResponse) VisitGenerateMeetingSummaryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetMeetingSummaryByIdRequestObject struct {
	MeetingID string `json:"MeetingID"`
}

type GetMeetingSummaryByIdResponseObject interface {
	VisitGetMeetingSummaryByIdResponse(w http.ResponseWriter) error
}

type GetMeetingSummaryById200JSONResponse map[string]interface{}

func (response GetMeetingSummaryById200JSONResponse) VisitGetMeetingSummaryByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get meeting summaries
	// (GET /api/meetings/summary)
	GetMeetingSummaries(ctx context.Context, request GetMeetingSummariesRequestObject) (GetMeetingSummariesResponseObject, error)
	// Generate meeting summary
	// (POST /api/meetings/summary)
	GenerateMeetingSummary(ctx context.Context, request GenerateMeetingSummaryRequestObject) (GenerateMeetingSummaryResponseObject, error)
	// Get meeting summary by ID
	// (GET /api/meetings/summary/{MeetingID})
	GetMeetingSummaryById(ctx context.Context, request GetMeetingSummaryByIdRequestObject) (GetMeetingSummaryByIdResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetMeetingSummaries operation middleware
func (sh *strictHandler) GetMeetingSummaries(w http.ResponseWriter, r *http.Request) {
	var request GetMeetingSummariesRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetMeetingSummaries(ctx, request.(GetMeetingSummariesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMeetingSummaries")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetMeetingSummariesResponseObject); ok {
		if err := validResponse.VisitGetMeetingSummariesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GenerateMeetingSummary operation middleware
func (sh *strictHandler) GenerateMeetingSummary(w http.ResponseWriter, r *http.Request) {
	var request GenerateMeetingSummaryRequestObject

	var body GenerateMeetingSummaryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GenerateMeetingSummary(ctx, request.(GenerateMeetingSummaryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GenerateMeetingSummary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GenerateMeetingSummaryResponseObject); ok {
		if err := validResponse.VisitGenerateMeetingSummaryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetMeetingSummaryById operation middleware
func (sh *strictHandler) GetMeetingSummaryById(w http.ResponseWriter, r *http.Request, meetingID string) {
	var request GetMeetingSummaryByIdRequestObject

	request.MeetingID = meetingID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetMeetingSummaryById(ctx, request.(GetMeetingSummaryByIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMeetingSummaryById")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetMeetingSummaryByIdResponseObject); ok {
		if err := validResponse.VisitGetMeetingSummaryByIdResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/xFhfqhvHAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
